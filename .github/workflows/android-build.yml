name: Build Android (force JVM 17 + artifact)

on:
  push:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      PROJECT_ROOT: Titan            # root folder of the project in the repo
      APP_MODULE: app               # Gradle module name (folder under PROJECT_ROOT)
      ANDROID_SDK_ROOT: /usr/local/lib/android/sdk

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Java 17 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Set up Android SDK
        shell: bash
        run: |
          set -euo pipefail
          sudo mkdir -p "$ANDROID_SDK_ROOT"
          sudo chown -R $USER:$USER "$ANDROID_SDK_ROOT"
          echo "y" | sudo "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --licenses || true ||:
          "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" "platforms;android-34" "build-tools;34.0.0"

      # Optional: unzip skeleton if present (kept because you used it before)
      - name: Unzip TitanApp_Rebuild.zip (if present)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f TitanApp_Rebuild.zip ]; then
            echo "Found TitanApp_Rebuild.zip – extracting into ./"
            unzip -o TitanApp_Rebuild.zip
          else
            echo "No TitanApp_Rebuild.zip found – skipping."
          fi

      # ---- Compatibility guard: force Kotlin & Java to JVM 17 without modifying your repo ----
      - name: Force Java/Kotlin JVM target to 17 (Gradle init script)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${HOME}/.gradle/init.d"
          cat > "${HOME}/.gradle/init.d/force17.gradle.kts" <<'EOF'
          import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
          import org.gradle.api.tasks.compile.JavaCompile

          allprojects {
              tasks.withType(KotlinCompile::class.java).configureEach {
                  kotlinOptions.jvmTarget = "17"
              }
              tasks.withType(JavaCompile::class.java).configureEach {
                  sourceCompatibility = "17"
                  targetCompatibility = "17"
                  // use --release 17 if available
                  try {
                      options.release.set(17)
                  } catch (_: Throwable) { }
              }
          }
          EOF

      # Make wrapper executable if it exists
      - name: Make gradlew executable (if present)
        shell: bash
        working-directory: ${{ env.PROJECT_ROOT }}
        run: |
          if [ -f ./gradlew ]; then
            chmod +x ./gradlew
          fi

      # Build (full log)
      - name: Build Debug APK
        shell: bash
        run: |
          set -euo pipefail
          cd "${PROJECT_ROOT}"
          if [ -f ./gradlew ]; then
            ./gradlew --no-daemon :${APP_MODULE}:assembleDebug -s --stacktrace
          else
            echo "gradlew not found at ${PROJECT_ROOT}/gradlew"
            exit 2
          fi

      # ---- Helpful diagnostics on failure ----
      - name: Summarize Gradle errors (best-effort)
        if: failure()
        shell: bash
        run: |
          echo "==== Looking for Kotlin/Java error lines ===="
          grep -RIn --line-number --no-messages -E ": error:| FAILED|What went wrong|Execution failed for task" "${{ env.PROJECT_ROOT }}" || true

      - name: Show any APKs that exist (any path)
        if: always()
        shell: bash
        run: |
          set -e
          echo "Searching for APKs…"
          find . -type f -name "*.apk" -print || true

      - name: "Debug: print project structure on failure"
        if: failure()
        shell: bash
        run: |
          echo "== repo root =="
          ls -la
          echo "== quick tree (depth 3) =="
          find "${PROJECT_ROOT}" -maxdepth 3 -print

      # ---- Compute artifact name + path (uses module-standard location) ----
      - name: Compute artifact name
        id: artifact
        shell: bash
        run: |
          set -euo pipefail
          # module-standard debug output location for APKs
          APK_DIR="${{ env.PROJECT_ROOT }}/${{ env.APP_MODULE }}/build/outputs/apk/debug"
          if [ ! -d "${APK_DIR}" ]; then
            echo "APK directory not found: ${APK_DIR}"
            exit 1
          fi
          APK=$(ls -1 "${APK_DIR}"/*.apk | head -n 1 || true)
          if [ -z "${APK}" ]; then
            echo "No APKs found in ${APK_DIR}"
            exit 1
          fi
          # final, nice artifact name
          TS=$(date +%Y%m%d-%H%M%S)
          NAME="Titan-${{ env.APP_MODULE }}-debug-${TS}.apk"
          echo "apk_name=${NAME}" >> "$GITHUB_OUTPUT"
          echo "apk_path=${APK}"  >> "$GITHUB_OUTPUT"
          echo "Computed: name=${NAME}, path=${APK}"

      - name: Upload APK artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.apk_name }}
          path: ${{ steps.artifact.outputs.apk_path }}
          if-no-files-found: warn
